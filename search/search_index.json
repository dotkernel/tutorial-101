{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tutorial-101 Book tutorial starting from Dotkernel Light: Level 101 beginner BRANCH : - main unde e documentatia , se compileaza documentatia. aplicatie din light, deploy functional !!!! --&gt; 101.dotkernel.net 1. instalezi light la tine pe WSL2 2. iei chapter 1, citesti documentation, implementezi una cite una - CHAPTER-1-doctrine # protected - including Light, and add visible DIFF between branches - CHAPTER-2- forms # protected - CHAPTER-3- inputfilter # protected - CHAPTER-4 -list books # protected main: incepi de la light , clone - adaigi folderul docs/book cu structura asta https://github.com/dotkernel/dot-session/tree/5.0/docs/book - cu fisier symlink si etc.","title":"Home"},{"location":"#tutorial-101","text":"Book tutorial starting from Dotkernel Light: Level 101 beginner","title":"tutorial-101"},{"location":"#branch-main-unde-e-documentatia-se-compileaza-documentatia-aplicatie-din-light-deploy-functional-101dotkernelnet","text":"1. instalezi light la tine pe WSL2 2. iei chapter 1, citesti documentation, implementezi una cite una - CHAPTER-1-doctrine # protected - including Light, and add visible DIFF between branches - CHAPTER-2- forms # protected - CHAPTER-3- inputfilter # protected - CHAPTER-4 -list books # protected main: incepi de la light , clone - adaigi folderul docs/book cu structura asta https://github.com/dotkernel/dot-session/tree/5.0/docs/book - cu fisier symlink si etc.","title":"BRANCH : - main unde e documentatia , se compileaza documentatia. aplicatie din light, deploy functional !!!! --&gt; 101.dotkernel.net"},{"location":"v1/chapter-1/","text":"Installing Doctrine Composer Requirements The first step is to add alongside your current packages the required entries for our Doctrine installation. We would add the following to our composer.json file located in our root folder: \"dotkernel/dot-cache\": \"^4.0\", \"ramsey/uuid\": \"^4.5.0\", \"ramsey/uuid-doctrine\": \"^2.1.0\", \"roave/psr-container-doctrine\": \"^5.2.2 || ^6.0.0\", dotkernel/dot-cache Provides caching support for Dotkernel applications. It offers a PSR-6 and PSR-16 compatible caching system that integrates smoothly with Dotkernel's service container. ramsey/uuid A widely used PHP library for generating and working with UUIDs (Universally Unique Identifiers). It supports multiple UUID versions. ramsey/uuid-doctrine Adds UUID support to Doctrine ORM using ramsey/uuid. It allows Doctrine to store and retrieve UUIDs as proper value objects instead of plain strings, improving type safety. roave/psr-container-doctrine Provides a set of factory classes that integrate Doctrine ORM with any PSR-11 container. It simplifies wiring Doctrine EntityManager, DBAL, configuration, and related services in frameworks like Dotkernel. phpstan/phpstan-doctrine (dev requirement) An extension for PHPStan that improves static analysis for Doctrine. It understands entity metadata, repositories, and common Doctrine patterns, helping catch errors during development. Setting Up Doctrine After successfully installing our dependencies, we now need to configure our Doctrine instance. Declare your database In the file config/autoload/local.php the structure would be updated like this: $databases = [ 'default' =&gt; [ 'host' =&gt; 'localhost', 'dbname' =&gt; 'light', 'user' =&gt; 'root', 'password' =&gt; '123', 'port' =&gt; 3306, 'driver' =&gt; 'pdo_mysql', 'charset' =&gt; 'utf8mb4', 'collate' =&gt; 'utf8mb4_general_ci', ], // you can add more database connections into this array ]; return [ 'databases' =&gt; $databases, 'doctrine' =&gt; [ 'connection' =&gt; [ 'orm_default' =&gt; [ 'params' =&gt; $databases['default'], ], ], ], // the rest of your configuration ]; Declare the Doctrine Drivers With the very nice utility of the package laminas/laminas-config-aggregator we can declare our doctrine settings in the src/App/src/ConfigProvider.php file. This package takes all the provided configs from the config/config.php file and merges them into one. Our new src/App/src/ConfigProvider.php class would look like this now: public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), 'doctrine' =&gt; $this-&gt;getDoctrineConfig(), 'templates' =&gt; $this-&gt;getTemplates(), ]; } public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, ], ], 'factories' =&gt; [ 'doctrine.entity_manager.orm_default' =&gt; EntityManagerFactory::class, GetIndexViewHandler::class =&gt; GetIndexViewHandlerFactory::class, ], 'aliases' =&gt; [ EntityManager::class =&gt; 'doctrine.entity_manager.orm_default', EntityManagerInterface::class =&gt; 'doctrine.entity_manager.orm_default', ], ]; } private function getDoctrineConfig(): array { return [ 'cache' =&gt; [ 'array' =&gt; [ 'class' =&gt; ArrayAdapter::class, ], 'filesystem' =&gt; [ 'class' =&gt; FilesystemAdapter::class, 'directory' =&gt; getcwd() . '/data/cache', 'namespace' =&gt; 'doctrine', ], ], 'configuration' =&gt; [ 'orm_default' =&gt; [ 'result_cache' =&gt; 'filesystem', 'metadata_cache' =&gt; 'filesystem', 'query_cache' =&gt; 'filesystem', 'hydration_cache' =&gt; 'array', 'typed_field_mapper' =&gt; null, 'second_level_cache' =&gt; [ 'enabled' =&gt; true, 'default_lifetime' =&gt; 3600, 'default_lock_lifetime' =&gt; 60, 'file_lock_region_directory' =&gt; '', 'regions' =&gt; [], ], ], ], 'driver' =&gt; [ // The default metadata driver aggregates all other drivers into a single one. // Override `orm_default` only if you know what you're doing. 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, ], ], 'types' =&gt; [ UuidType::NAME =&gt; UuidType::class, ], ]; } Running doctrine Now that everything has been configured we only need to do one last thing, to create an executable for the Doctrine CLI. In our case we will create a doctrine file inside the application's bin directory: #!/usr/bin/env php &lt;?php declare(strict_types=1); use Doctrine\\ORM\\EntityManager; use Doctrine\\ORM\\Tools\\Console\\ConsoleRunner; use Doctrine\\ORM\\Tools\\Console\\EntityManagerProvider\\SingleManagerProvider; require_once 'vendor/autoload.php'; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); ConsoleRunner::run(new SingleManagerProvider($entityManager)); Now by running the command bellow we should see the Doctrine CLI version alongside its available commands: php ./bin/doctrine Example (truncated) output: Doctrine Command Line Interface 3.5.7.0 Options: -h, --help Display help for the given command. When no command is given display help for the list command --silent Do not output any message -q, --quiet Only errors are displayed. All other output is suppressed -V, --version Display this application version --ansi|--no-ansi Force (or disable --no-ansi) ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug","title":"Chapter 1"},{"location":"v1/chapter-1/#installing-doctrine","text":"","title":"Installing Doctrine"},{"location":"v1/chapter-1/#composer-requirements","text":"The first step is to add alongside your current packages the required entries for our Doctrine installation. We would add the following to our composer.json file located in our root folder: \"dotkernel/dot-cache\": \"^4.0\", \"ramsey/uuid\": \"^4.5.0\", \"ramsey/uuid-doctrine\": \"^2.1.0\", \"roave/psr-container-doctrine\": \"^5.2.2 || ^6.0.0\", dotkernel/dot-cache Provides caching support for Dotkernel applications. It offers a PSR-6 and PSR-16 compatible caching system that integrates smoothly with Dotkernel's service container. ramsey/uuid A widely used PHP library for generating and working with UUIDs (Universally Unique Identifiers). It supports multiple UUID versions. ramsey/uuid-doctrine Adds UUID support to Doctrine ORM using ramsey/uuid. It allows Doctrine to store and retrieve UUIDs as proper value objects instead of plain strings, improving type safety. roave/psr-container-doctrine Provides a set of factory classes that integrate Doctrine ORM with any PSR-11 container. It simplifies wiring Doctrine EntityManager, DBAL, configuration, and related services in frameworks like Dotkernel. phpstan/phpstan-doctrine (dev requirement) An extension for PHPStan that improves static analysis for Doctrine. It understands entity metadata, repositories, and common Doctrine patterns, helping catch errors during development.","title":"Composer Requirements"},{"location":"v1/chapter-1/#setting-up-doctrine","text":"After successfully installing our dependencies, we now need to configure our Doctrine instance.","title":"Setting Up Doctrine"},{"location":"v1/chapter-1/#running-doctrine","text":"Now that everything has been configured we only need to do one last thing, to create an executable for the Doctrine CLI. In our case we will create a doctrine file inside the application's bin directory: #!/usr/bin/env php &lt;?php declare(strict_types=1); use Doctrine\\ORM\\EntityManager; use Doctrine\\ORM\\Tools\\Console\\ConsoleRunner; use Doctrine\\ORM\\Tools\\Console\\EntityManagerProvider\\SingleManagerProvider; require_once 'vendor/autoload.php'; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); ConsoleRunner::run(new SingleManagerProvider($entityManager)); Now by running the command bellow we should see the Doctrine CLI version alongside its available commands: php ./bin/doctrine Example (truncated) output: Doctrine Command Line Interface 3.5.7.0 Options: -h, --help Display help for the given command. When no command is given display help for the list command --silent Do not output any message -q, --quiet Only errors are displayed. All other output is suppressed -V, --version Display this application version --ansi|--no-ansi Force (or disable --no-ansi) ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug","title":"Running doctrine"},{"location":"v1/introduction/","text":"Introduction For the upcoming tutorial steps we assume that you already have installed the following: A UNIX-based development environment. If not, we recommend AlmaLinux in a WSL2 container. You can check our guide for setting up your container. A recent IDE, for example, PhpStorm or VSCode A fresh installation of Dotkernel Light Default UTF-8 encoding for files and LF type line separator Feel free to check out our development documentation in case of any further questions.","title":"Introduction"},{"location":"v1/introduction/#introduction","text":"For the upcoming tutorial steps we assume that you already have installed the following: A UNIX-based development environment. If not, we recommend AlmaLinux in a WSL2 container. You can check our guide for setting up your container. A recent IDE, for example, PhpStorm or VSCode A fresh installation of Dotkernel Light Default UTF-8 encoding for files and LF type line separator Feel free to check out our development documentation in case of any further questions.","title":"Introduction"}]}