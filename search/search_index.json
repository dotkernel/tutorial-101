{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tutorial-101 Book tutorial starting from Dotkernel Light: Level 101 beginner","title":"Home"},{"location":"#tutorial-101","text":"Book tutorial starting from Dotkernel Light: Level 101 beginner","title":"tutorial-101"},{"location":"v1/chapter-1/","text":"Installing Doctrine Composer Requirements The first step is to add alongside your current packages the required entries for our Doctrine installation. We would add the following to our composer.json file located in our root folder: \"dotkernel/dot-cache\": \"^4.0\", \"ramsey/uuid\": \"^4.5.0\", \"ramsey/uuid-doctrine\": \"^2.1.0\", \"roave/psr-container-doctrine\": \"^5.2.2 || ^6.0.0\", dotkernel/dot-cache Provides caching support for Dotkernel applications. It offers a PSR-6 and PSR-16 compatible caching system that integrates smoothly with Dotkernel's service container. ramsey/uuid A widely used PHP library for generating and working with UUIDs (Universally Unique Identifiers). It supports multiple UUID versions. ramsey/uuid-doctrine Adds UUID support to Doctrine ORM using ramsey/uuid. It allows Doctrine to store and retrieve UUIDs as proper value objects instead of plain strings, improving type safety. roave/psr-container-doctrine Provides a set of factory classes that integrate Doctrine ORM with any PSR-11 container. It simplifies wiring Doctrine EntityManager, DBAL, configuration, and related services in frameworks like Dotkernel. phpstan/phpstan-doctrine (dev requirement) An extension for PHPStan that improves static analysis for Doctrine. It understands entity metadata, repositories, and common Doctrine patterns, helping catch errors during development. Update Composer Dependencies Run the following command to install the new required packages: composer update The command should be run whenever we change anything in our composer.json file. Setting Up Doctrine After successfully installing our dependencies, we now need to configure our Doctrine instance. Declare your database In the file config/autoload/local.php the structure would be updated like this: $databases = [ 'default' =&gt; [ 'host' =&gt; 'localhost', 'dbname' =&gt; 'light', 'user' =&gt; 'root', 'password' =&gt; '123', 'port' =&gt; 3306, 'driver' =&gt; 'pdo_mysql', 'charset' =&gt; 'utf8mb4', 'collate' =&gt; 'utf8mb4_general_ci', ], // you can add more database connections into this array ]; return [ 'databases' =&gt; $databases, 'doctrine' =&gt; [ 'connection' =&gt; [ 'orm_default' =&gt; [ 'params' =&gt; $databases['default'], ], ], ], // the rest of your configuration ]; Declare the Doctrine Drivers With the very nice utility of the package laminas/laminas-config-aggregator we can declare our doctrine settings in the src/App/src/ConfigProvider.php file. This package takes all the provided configs from the config/config.php file and merges them into one. Our new src/App/src/ConfigProvider.php class would look like this now: public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), 'doctrine' =&gt; $this-&gt;getDoctrineConfig(), 'templates' =&gt; $this-&gt;getTemplates(), ]; } public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, ], ], 'factories' =&gt; [ 'doctrine.entity_manager.orm_default' =&gt; EntityManagerFactory::class, GetIndexViewHandler::class =&gt; GetIndexViewHandlerFactory::class, ], 'aliases' =&gt; [ EntityManager::class =&gt; 'doctrine.entity_manager.orm_default', EntityManagerInterface::class =&gt; 'doctrine.entity_manager.orm_default', ], ]; } private function getDoctrineConfig(): array { return [ 'cache' =&gt; [ 'array' =&gt; [ 'class' =&gt; ArrayAdapter::class, ], 'filesystem' =&gt; [ 'class' =&gt; FilesystemAdapter::class, 'directory' =&gt; getcwd() . '/data/cache', 'namespace' =&gt; 'doctrine', ], ], 'configuration' =&gt; [ 'orm_default' =&gt; [ 'result_cache' =&gt; 'filesystem', 'metadata_cache' =&gt; 'filesystem', 'query_cache' =&gt; 'filesystem', 'hydration_cache' =&gt; 'array', 'typed_field_mapper' =&gt; null, 'second_level_cache' =&gt; [ 'enabled' =&gt; true, 'default_lifetime' =&gt; 3600, 'default_lock_lifetime' =&gt; 60, 'file_lock_region_directory' =&gt; '', 'regions' =&gt; [], ], ], ], 'driver' =&gt; [ // The default metadata driver aggregates all other drivers into a single one. // Override `orm_default` only if you know what you're doing. 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, ], ], 'types' =&gt; [ UuidType::NAME =&gt; UuidType::class, ], ]; } Running doctrine Now that everything has been configured we only need to do one last thing, to create an executable for the Doctrine CLI. In our case we will create a doctrine file inside the application's bin directory: #!/usr/bin/env php &lt;?php declare(strict_types=1); use Doctrine\\ORM\\EntityManager; use Doctrine\\ORM\\Tools\\Console\\ConsoleRunner; use Doctrine\\ORM\\Tools\\Console\\EntityManagerProvider\\SingleManagerProvider; require_once 'vendor/autoload.php'; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); ConsoleRunner::run(new SingleManagerProvider($entityManager)); Now by running the command bellow we should see the Doctrine CLI version alongside its available commands: php ./bin/doctrine Example (truncated) output: Doctrine Command Line Interface 3.5.7.0 Options: -h, --help Display help for the given command. When no command is given display help for the list command --silent Do not output any message -q, --quiet Only errors are displayed. All other output is suppressed -V, --version Display this application version --ansi|--no-ansi Force (or disable --no-ansi) ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug Summary [Modified] composer.json [Modified] config/autoload/local.php [Modified] src/App/src/ConfigProvider.php [+] bin/doctrine","title":"1. Installing Doctrine"},{"location":"v1/chapter-1/#installing-doctrine","text":"","title":"Installing Doctrine"},{"location":"v1/chapter-1/#composer-requirements","text":"The first step is to add alongside your current packages the required entries for our Doctrine installation. We would add the following to our composer.json file located in our root folder: \"dotkernel/dot-cache\": \"^4.0\", \"ramsey/uuid\": \"^4.5.0\", \"ramsey/uuid-doctrine\": \"^2.1.0\", \"roave/psr-container-doctrine\": \"^5.2.2 || ^6.0.0\", dotkernel/dot-cache Provides caching support for Dotkernel applications. It offers a PSR-6 and PSR-16 compatible caching system that integrates smoothly with Dotkernel's service container. ramsey/uuid A widely used PHP library for generating and working with UUIDs (Universally Unique Identifiers). It supports multiple UUID versions. ramsey/uuid-doctrine Adds UUID support to Doctrine ORM using ramsey/uuid. It allows Doctrine to store and retrieve UUIDs as proper value objects instead of plain strings, improving type safety. roave/psr-container-doctrine Provides a set of factory classes that integrate Doctrine ORM with any PSR-11 container. It simplifies wiring Doctrine EntityManager, DBAL, configuration, and related services in frameworks like Dotkernel. phpstan/phpstan-doctrine (dev requirement) An extension for PHPStan that improves static analysis for Doctrine. It understands entity metadata, repositories, and common Doctrine patterns, helping catch errors during development.","title":"Composer Requirements"},{"location":"v1/chapter-1/#setting-up-doctrine","text":"After successfully installing our dependencies, we now need to configure our Doctrine instance.","title":"Setting Up Doctrine"},{"location":"v1/chapter-1/#running-doctrine","text":"Now that everything has been configured we only need to do one last thing, to create an executable for the Doctrine CLI. In our case we will create a doctrine file inside the application's bin directory: #!/usr/bin/env php &lt;?php declare(strict_types=1); use Doctrine\\ORM\\EntityManager; use Doctrine\\ORM\\Tools\\Console\\ConsoleRunner; use Doctrine\\ORM\\Tools\\Console\\EntityManagerProvider\\SingleManagerProvider; require_once 'vendor/autoload.php'; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); ConsoleRunner::run(new SingleManagerProvider($entityManager)); Now by running the command bellow we should see the Doctrine CLI version alongside its available commands: php ./bin/doctrine Example (truncated) output: Doctrine Command Line Interface 3.5.7.0 Options: -h, --help Display help for the given command. When no command is given display help for the list command --silent Do not output any message -q, --quiet Only errors are displayed. All other output is suppressed -V, --version Display this application version --ansi|--no-ansi Force (or disable --no-ansi) ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug","title":"Running doctrine"},{"location":"v1/chapter-2/","text":"Entities and Migrations In the previous tutorial we have shown you how to install the basic functionality of Doctrine. In this tutorial we are going to show you how to make changes to the database schema through Entities and Migrations . What are Entities ? In Doctrine, entities are PHP classes that represent database tables. Each property in the class corresponds to a column in the table. Entities define the structure and behavior of your data. What are Migrations ? Doctrine migrations are version-controlled changes to the database schema. They allow you to safely update the structure of your database (create tables, add columns, etc.) over time — similar to Git for your database. Setting Up the Migrations Functionality To enable Doctrine migrations, we configure the migrations section in the getDoctrineConfig() function from src/App/ConfigProvider . This defines where migration files will be stored , as well as how the migration table is managed . The configuration includes settings for the migrations table, execution tracking, and the path where new migration classes will be generated. 'migrations' =&gt; [ 'table_storage' =&gt; [ 'table_name' =&gt; 'doctrine_migration_versions', 'version_column_name' =&gt; 'version', 'version_column_length' =&gt; 191, 'executed_at_column_name' =&gt; 'executed_at', 'execution_time_column_name' =&gt; 'execution_time', ], // Modify this line based on where you would like to have your migrations 'migrations_paths' =&gt; [ 'Migrations' =&gt; 'src/App/src/Migration', ], 'all_or_nothing' =&gt; true, 'check_database_platform' =&gt; true, ], Along with those we also need to create the file config/cli-config.php . This cli-config.php file sets up Doctrine so that you can run migration commands from the command line (CLI). It connects the Doctrine Migrations system with your application's existing EntityManager . &lt;?php declare(strict_types=1); use Doctrine\\Migrations\\Configuration\\EntityManager\\ExistingEntityManager; use Doctrine\\Migrations\\Configuration\\Migration\\ConfigurationArray; use Doctrine\\Migrations\\DependencyFactory; use Doctrine\\ORM\\EntityManager; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); return DependencyFactory::fromEntityManager( new ConfigurationArray($container-&gt;get('config')['doctrine']['migrations']), new ExistingEntityManager($entityManager) ); Used UUID type In our latest releases we have decided to switch from a binary UUID to a string UUID . Because of that, we are also implementing our own custom UUID type in the folder src/App/src/DBAL/Types/UuidType.php . With this method we can also add our own custom types in the future. &lt;?php declare(strict_types=1); namespace Light\\App\\DBAL\\Types; use Doctrine\\DBAL\\Platforms\\AbstractPlatform; class UuidType extends \\Ramsey\\Uuid\\Doctrine\\UuidType { public const NAME = 'uuid'; public function getSQLDeclaration(array $column, AbstractPlatform $platform): string { return 'UUID'; } } Testing Our Doctrine Migrations Configuration For easier usage of this functionality, we will create a file bin/doctrine-migrations . This will give us an easier way of executing migrations operations. #!/usr/bin/env php &lt;?php declare(strict_types=1); namespace Doctrine\\Migrations; require __DIR__ . '/../vendor/doctrine/migrations/bin/doctrine-migrations.php'; We can now call: php bin/doctrine-migrations The call should lead to a call that contains the following output: migrations:current [current] Outputs the current version migrations:diff [diff] Generate a migration by comparing your current database to your mapping information. migrations:dump-schema [dump-schema] Dump the schema for your database to a migration. migrations:execute [execute] Execute one or more migration versions up or down manually. migrations:generate [generate] Generate a blank migration class. migrations:latest [latest] Outputs the latest version migrations:list [list-migrations] Display a list of all available migrations and their status. migrations:migrate [migrate] Execute a migration to a specified version or the latest available version. migrations:rollup [rollup] Rollup migrations by deleting all tracked versions and insert the one version that exists. migrations:status [status] View the status of a set of migrations. migrations:sync-metadata-storage [sync-metadata-storage] Ensures that the metadata storage is at the latest version. migrations:up-to-date [up-to-date] Tells you if your schema is up-to-date. migrations:version [version] Manually add and delete migration versions from the version table. Creating our Entities Now that we have set up the Doctrine Migrations, we shall now start working on our entities. We need to create a base for our entities so that they have the same starting point. For that, we will add a new directory src/App/src/Entity in which we will add an abstract class, AbstractEntity.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Entity; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; use Laminas\\Stdlib\\ArraySerializableInterface; use Ramsey\\Uuid\\Uuid; use Ramsey\\Uuid\\UuidInterface; use function is_array; use function method_exists; use function ucfirst; #[ORM\\MappedSuperclass] abstract class AbstractEntity implements ArraySerializableInterface { #[ORM\\Id] #[ORM\\Column(name: 'id', type: 'uuid', unique: true, nullable: false)] protected UuidInterface $id; #[ORM\\Column(name: 'created', type: 'datetime_immutable', nullable: false)] protected DateTimeImmutable $created; #[ORM\\Column(name: 'updated', type: 'datetime_immutable', nullable: true)] protected ?DateTimeImmutable $updated = null; public function __construct() { $this-&gt;id = Uuid::uuid7(); } public function getId(): UuidInterface { return $this-&gt;id; } public function setId(UuidInterface $id): static { $this-&gt;id = $id; return $this; } public function getCreated(): ?DateTimeImmutable { return $this-&gt;created; } public function getCreatedFormatted(string $dateFormat = 'Y-m-d H:i:s'): string { return $this-&gt;created-&gt;format($dateFormat); } public function getUpdated(): ?DateTimeImmutable { return $this-&gt;updated; } public function getUpdatedFormatted(string $dateFormat = 'Y-m-d H:i:s'): ?string { if ($this-&gt;updated instanceof DateTimeImmutable) { return $this-&gt;updated-&gt;format($dateFormat); } return null; } #[ORM\\PrePersist] public function created(): void { $this-&gt;created = new DateTimeImmutable(); } #[ORM\\PreUpdate] public function touch(): void { $this-&gt;updated = new DateTimeImmutable(); } /** * @param array&lt;non-empty-string, mixed&gt; $array */ public function exchangeArray(array $array): void { foreach ($array as $property =&gt; $values) { if (is_array($values)) { $method = 'add' . ucfirst($property); if (! method_exists($this, $method)) { continue; } foreach ($values as $value) { $this-&gt;$method($value); } } else { $method = 'set' . ucfirst($property); if (! method_exists($this, $method)) { continue; } $this-&gt;$method($values); } } } } We extend this class to any Entity that we create so that all can have an identifier( id ), a field for knowing when it was created and one to mark a point in time for when we update it. It is time to finally time to work on our Book Entity. We now create a new module with the location src/Book/src . In this module we create a directory called Entity in which we shall create our Book.php class. &lt;?php declare(strict_types=1); namespace Light\\Book\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Light\\App\\Entity\\AbstractEntity; use Light\\Book\\Repository\\BookRepository; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(name: 'books')] #[ORM\\HasLifecycleCallbacks] class Book extends AbstractEntity { #[ORM\\Column(name: 'title', type: 'string', length: 500)] private string $title; #[ORM\\Column(name: 'author', type: 'string', length: 500)] private string $author; public function getTitle(): ?string { return $this-&gt;title; } public function setTitle(string $title): void { $this-&gt;title = $title; } public function getAuthor(): ?string { return $this-&gt;author; } public function setAuthor(string $author): void { $this-&gt;author = $author; } /** * @return array{ * id: non-empty-string, * title: string, * author: string * } */ public function getArrayCopy(): array { return [ 'id' =&gt; $this-&gt;id-&gt;toString(), 'title' =&gt; $this-&gt;title, 'author' =&gt; $this-&gt;author, ]; } } In the book class you can see various Doctrine tags such as #[ORM\\Table(name: 'books')] which specify the name of the table that will be related to this Entity. There are many tags that can be added, but for the sake of simplicity, we will stick to the table and the columns that will populate it. Repositories In the class we created earlier, you may have noticed that our Entity is linked to a Repository using the following annotation: #[ORM\\Entity(repositoryClass: BookRepository::class)] . This specifies which Repository will handle queries for this Entity. This allows us to write custom database logic for it. Same as for the Entities, we need to create a base and our future Repositories. Because of that, we will create two new directories: src/App/src/Repository and src/Book/src/Repository . Two repositories shall be created: src/App/src/Repository/AbstractRepository.php &lt;?php declare(strict_types=1); namespace Light\\App\\Repository; use Doctrine\\ORM\\EntityRepository; use Doctrine\\ORM\\QueryBuilder; use Light\\App\\Entity\\EntityInterface; /** * @extends EntityRepository&lt;object&gt; */ class AbstractRepository extends EntityRepository { public function deleteResource(EntityInterface $resource): void { $this-&gt;getEntityManager()-&gt;remove($resource); $this-&gt;getEntityManager()-&gt;flush(); } public function getQueryBuilder(): QueryBuilder { return $this-&gt;getEntityManager()-&gt;createQueryBuilder(); } public function saveResource(EntityInterface $resource): void { $this-&gt;getEntityManager()-&gt;persist($resource); $this-&gt;getEntityManager()-&gt;flush(); } } src/App/src/Book/BookRepository.php &lt;?php declare(strict_types=1); namespace Light\\Book\\Repository; use Light\\App\\Repository\\AbstractRepository; class BookRepository extends AbstractRepository { /** * Any other custom methods can be added here */ } The BookRepository.php , for example, can implement functions that list books based on specific authors or titles. However, this will not be covered in this chapter of the tutorial. Final Steps We have 3 final steps: registering our Book module registering our new namespace in composer.json running the migrations Step 1 In order to register our new module, we need a new ConfigProvider.php in our src/Book/src folder. In this class we configure Doctrine to know from where to get our Entities. &lt;?php declare(strict_types=1); namespace Light\\Book; use Doctrine\\ORM\\Mapping\\Driver\\AttributeDriver; use Doctrine\\Persistence\\Mapping\\Driver\\MappingDriver; class ConfigProvider { public function __invoke(): array { return [ 'doctrine' =&gt; $this-&gt;getDoctrineConfig(), ]; } private function getDoctrineConfig(): array { return [ 'driver' =&gt; [ 'orm_default' =&gt; [ 'drivers' =&gt; [ 'Light\\Book\\Entity' =&gt; 'BookEntities', ], ], 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; [__DIR__ . '/Entity'], ], ], ]; } } This class should be added in config/config.php . \\Light\\Book\\ConfigProvider::class, Step 2 Registering the namespace is fairly simple. We just add it in our composer.json file by adding \"Light\\\\Book\\\\\": \"src/Book/src/\" under the autoload . psr-4 key: , \"Light\\\\Book\\\\\": \"src/Book/src/\" We now have to run the following command to have it registered: composer dump-autoload The module is now registered. Step 3 For the last step we will create a migration using our bin/doctrine-migrations file and then execute it: php bin/doctrine-migrations migrations:diff You should get an output similar to: Generated new migration class to \"src/App/src/Migration/Version20251127183637.php\" The migrations:diff flag tells Doctrine to compare our current database schema and create a file in which the differences will be transformed into SQL syntax. Inside this file you should have something similar to: final class Version20251127183637 extends AbstractMigration { public function getDescription(): string { return ''; } public function up(Schema $schema): void { // this up() migration is auto-generated, please modify it to your needs $this-&gt;addSql('CREATE TABLE books (title VARCHAR(500) DEFAULT NULL, author VARCHAR(500) DEFAULT NULL, id UUID NOT NULL, created DATETIME NOT NULL, updated DATETIME DEFAULT NULL, PRIMARY KEY (id)) DEFAULT CHARACTER SET utf8mb4'); } public function down(Schema $schema): void { // this down() migration is auto-generated, please modify it to your needs $this-&gt;addSql('DROP TABLE books'); } } We only have to execute the migrations now with the command: php bin/doctrine-migrations migrations:migrate The output should be similar to this: [OK] Successfully migrated to version: Migrations\\Version2025112718363 Summary [Modified] src/App/src/ConfigProvider.php [+] config/cli-config.php [+] src/App/src/DBAL/Types/UuidType.php [+] bin/doctrine-migrations [+] src/App/src/Entity/AbstractEntity.php [+] src/Book/src/Entity/Book.php [+] src/App/src/Repository/AbstractRepository.php [+] src/App/src/Book/BookRepository.php [+] src/Book/src/ConfigProvider.php [Modified] config/config.php [Modified] composer.json [+] src/App/src/Migration/Version{date_time}.php","title":"2. Entities and Migrations"},{"location":"v1/chapter-2/#entities-and-migrations","text":"In the previous tutorial we have shown you how to install the basic functionality of Doctrine. In this tutorial we are going to show you how to make changes to the database schema through Entities and Migrations .","title":"Entities and Migrations"},{"location":"v1/chapter-2/#what-are-entities","text":"In Doctrine, entities are PHP classes that represent database tables. Each property in the class corresponds to a column in the table. Entities define the structure and behavior of your data.","title":"What are Entities ?"},{"location":"v1/chapter-2/#what-are-migrations","text":"Doctrine migrations are version-controlled changes to the database schema. They allow you to safely update the structure of your database (create tables, add columns, etc.) over time — similar to Git for your database.","title":"What are Migrations ?"},{"location":"v1/chapter-2/#setting-up-the-migrations-functionality","text":"To enable Doctrine migrations, we configure the migrations section in the getDoctrineConfig() function from src/App/ConfigProvider . This defines where migration files will be stored , as well as how the migration table is managed . The configuration includes settings for the migrations table, execution tracking, and the path where new migration classes will be generated. 'migrations' =&gt; [ 'table_storage' =&gt; [ 'table_name' =&gt; 'doctrine_migration_versions', 'version_column_name' =&gt; 'version', 'version_column_length' =&gt; 191, 'executed_at_column_name' =&gt; 'executed_at', 'execution_time_column_name' =&gt; 'execution_time', ], // Modify this line based on where you would like to have your migrations 'migrations_paths' =&gt; [ 'Migrations' =&gt; 'src/App/src/Migration', ], 'all_or_nothing' =&gt; true, 'check_database_platform' =&gt; true, ], Along with those we also need to create the file config/cli-config.php . This cli-config.php file sets up Doctrine so that you can run migration commands from the command line (CLI). It connects the Doctrine Migrations system with your application's existing EntityManager . &lt;?php declare(strict_types=1); use Doctrine\\Migrations\\Configuration\\EntityManager\\ExistingEntityManager; use Doctrine\\Migrations\\Configuration\\Migration\\ConfigurationArray; use Doctrine\\Migrations\\DependencyFactory; use Doctrine\\ORM\\EntityManager; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); return DependencyFactory::fromEntityManager( new ConfigurationArray($container-&gt;get('config')['doctrine']['migrations']), new ExistingEntityManager($entityManager) );","title":"Setting Up the Migrations Functionality"},{"location":"v1/chapter-2/#used-uuid-type","text":"In our latest releases we have decided to switch from a binary UUID to a string UUID . Because of that, we are also implementing our own custom UUID type in the folder src/App/src/DBAL/Types/UuidType.php . With this method we can also add our own custom types in the future. &lt;?php declare(strict_types=1); namespace Light\\App\\DBAL\\Types; use Doctrine\\DBAL\\Platforms\\AbstractPlatform; class UuidType extends \\Ramsey\\Uuid\\Doctrine\\UuidType { public const NAME = 'uuid'; public function getSQLDeclaration(array $column, AbstractPlatform $platform): string { return 'UUID'; } }","title":"Used UUID type"},{"location":"v1/chapter-2/#testing-our-doctrine-migrations-configuration","text":"For easier usage of this functionality, we will create a file bin/doctrine-migrations . This will give us an easier way of executing migrations operations. #!/usr/bin/env php &lt;?php declare(strict_types=1); namespace Doctrine\\Migrations; require __DIR__ . '/../vendor/doctrine/migrations/bin/doctrine-migrations.php'; We can now call: php bin/doctrine-migrations The call should lead to a call that contains the following output: migrations:current [current] Outputs the current version migrations:diff [diff] Generate a migration by comparing your current database to your mapping information. migrations:dump-schema [dump-schema] Dump the schema for your database to a migration. migrations:execute [execute] Execute one or more migration versions up or down manually. migrations:generate [generate] Generate a blank migration class. migrations:latest [latest] Outputs the latest version migrations:list [list-migrations] Display a list of all available migrations and their status. migrations:migrate [migrate] Execute a migration to a specified version or the latest available version. migrations:rollup [rollup] Rollup migrations by deleting all tracked versions and insert the one version that exists. migrations:status [status] View the status of a set of migrations. migrations:sync-metadata-storage [sync-metadata-storage] Ensures that the metadata storage is at the latest version. migrations:up-to-date [up-to-date] Tells you if your schema is up-to-date. migrations:version [version] Manually add and delete migration versions from the version table.","title":"Testing Our Doctrine Migrations Configuration"},{"location":"v1/chapter-2/#creating-our-entities","text":"Now that we have set up the Doctrine Migrations, we shall now start working on our entities. We need to create a base for our entities so that they have the same starting point. For that, we will add a new directory src/App/src/Entity in which we will add an abstract class, AbstractEntity.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Entity; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; use Laminas\\Stdlib\\ArraySerializableInterface; use Ramsey\\Uuid\\Uuid; use Ramsey\\Uuid\\UuidInterface; use function is_array; use function method_exists; use function ucfirst; #[ORM\\MappedSuperclass] abstract class AbstractEntity implements ArraySerializableInterface { #[ORM\\Id] #[ORM\\Column(name: 'id', type: 'uuid', unique: true, nullable: false)] protected UuidInterface $id; #[ORM\\Column(name: 'created', type: 'datetime_immutable', nullable: false)] protected DateTimeImmutable $created; #[ORM\\Column(name: 'updated', type: 'datetime_immutable', nullable: true)] protected ?DateTimeImmutable $updated = null; public function __construct() { $this-&gt;id = Uuid::uuid7(); } public function getId(): UuidInterface { return $this-&gt;id; } public function setId(UuidInterface $id): static { $this-&gt;id = $id; return $this; } public function getCreated(): ?DateTimeImmutable { return $this-&gt;created; } public function getCreatedFormatted(string $dateFormat = 'Y-m-d H:i:s'): string { return $this-&gt;created-&gt;format($dateFormat); } public function getUpdated(): ?DateTimeImmutable { return $this-&gt;updated; } public function getUpdatedFormatted(string $dateFormat = 'Y-m-d H:i:s'): ?string { if ($this-&gt;updated instanceof DateTimeImmutable) { return $this-&gt;updated-&gt;format($dateFormat); } return null; } #[ORM\\PrePersist] public function created(): void { $this-&gt;created = new DateTimeImmutable(); } #[ORM\\PreUpdate] public function touch(): void { $this-&gt;updated = new DateTimeImmutable(); } /** * @param array&lt;non-empty-string, mixed&gt; $array */ public function exchangeArray(array $array): void { foreach ($array as $property =&gt; $values) { if (is_array($values)) { $method = 'add' . ucfirst($property); if (! method_exists($this, $method)) { continue; } foreach ($values as $value) { $this-&gt;$method($value); } } else { $method = 'set' . ucfirst($property); if (! method_exists($this, $method)) { continue; } $this-&gt;$method($values); } } } } We extend this class to any Entity that we create so that all can have an identifier( id ), a field for knowing when it was created and one to mark a point in time for when we update it. It is time to finally time to work on our Book Entity. We now create a new module with the location src/Book/src . In this module we create a directory called Entity in which we shall create our Book.php class. &lt;?php declare(strict_types=1); namespace Light\\Book\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Light\\App\\Entity\\AbstractEntity; use Light\\Book\\Repository\\BookRepository; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(name: 'books')] #[ORM\\HasLifecycleCallbacks] class Book extends AbstractEntity { #[ORM\\Column(name: 'title', type: 'string', length: 500)] private string $title; #[ORM\\Column(name: 'author', type: 'string', length: 500)] private string $author; public function getTitle(): ?string { return $this-&gt;title; } public function setTitle(string $title): void { $this-&gt;title = $title; } public function getAuthor(): ?string { return $this-&gt;author; } public function setAuthor(string $author): void { $this-&gt;author = $author; } /** * @return array{ * id: non-empty-string, * title: string, * author: string * } */ public function getArrayCopy(): array { return [ 'id' =&gt; $this-&gt;id-&gt;toString(), 'title' =&gt; $this-&gt;title, 'author' =&gt; $this-&gt;author, ]; } } In the book class you can see various Doctrine tags such as #[ORM\\Table(name: 'books')] which specify the name of the table that will be related to this Entity. There are many tags that can be added, but for the sake of simplicity, we will stick to the table and the columns that will populate it.","title":"Creating our Entities"},{"location":"v1/chapter-2/#repositories","text":"In the class we created earlier, you may have noticed that our Entity is linked to a Repository using the following annotation: #[ORM\\Entity(repositoryClass: BookRepository::class)] . This specifies which Repository will handle queries for this Entity. This allows us to write custom database logic for it. Same as for the Entities, we need to create a base and our future Repositories. Because of that, we will create two new directories: src/App/src/Repository and src/Book/src/Repository . Two repositories shall be created: src/App/src/Repository/AbstractRepository.php &lt;?php declare(strict_types=1); namespace Light\\App\\Repository; use Doctrine\\ORM\\EntityRepository; use Doctrine\\ORM\\QueryBuilder; use Light\\App\\Entity\\EntityInterface; /** * @extends EntityRepository&lt;object&gt; */ class AbstractRepository extends EntityRepository { public function deleteResource(EntityInterface $resource): void { $this-&gt;getEntityManager()-&gt;remove($resource); $this-&gt;getEntityManager()-&gt;flush(); } public function getQueryBuilder(): QueryBuilder { return $this-&gt;getEntityManager()-&gt;createQueryBuilder(); } public function saveResource(EntityInterface $resource): void { $this-&gt;getEntityManager()-&gt;persist($resource); $this-&gt;getEntityManager()-&gt;flush(); } } src/App/src/Book/BookRepository.php &lt;?php declare(strict_types=1); namespace Light\\Book\\Repository; use Light\\App\\Repository\\AbstractRepository; class BookRepository extends AbstractRepository { /** * Any other custom methods can be added here */ } The BookRepository.php , for example, can implement functions that list books based on specific authors or titles. However, this will not be covered in this chapter of the tutorial.","title":"Repositories"},{"location":"v1/chapter-2/#final-steps","text":"We have 3 final steps: registering our Book module registering our new namespace in composer.json running the migrations","title":"Final Steps"},{"location":"v1/chapter-3/","text":"Fixtures and Custom Listing In the previous chapter, after we have created our Entities we have talked briefly about their related Repositories. In this chapter we are going to have a closer look at them along with a custom listing of our books. Repository Logic Update Our goal is to create two custom functions that would retrieve the titles and the authors separately from each book. In src/Book/src/Respository/BookRepository.php we should add the following code: /** * @return array&lt;int, array{id: non-empty-string, title: string}&gt; */ public function getTitles(): array { $qb = $this-&gt;getQueryBuilder() -&gt;select('book.id, book.title') -&gt;from(Book::class, 'book'); return $qb-&gt;getQuery()-&gt;getResult(); } /** * @return array&lt;int, array{id: non-empty-string, author: string}&gt; */ public function getAuthors(): array { $qb = $this-&gt;getQueryBuilder() -&gt;select('book.id, book.author') -&gt;from(Book::class, 'book'); return $qb-&gt;getQuery()-&gt;getResult(); } The functions listed above will retrieve the title / author along with the ID of the Book database row for reference. Setting up the Route We will now work on setting up the route from our new module through which we will display our data. For this tutorial our route will be {{base_url}}/books . In order to register this path we need to create a RoutesDelegator.php file in src/Book/src . &lt;?php declare(strict_types=1); namespace Light\\Book; use Light\\Book\\Handler\\GetBooksHandler; use Mezzio\\Application; use Psr\\Container\\ContainerInterface; use function assert; class RoutesDelegator { public function __invoke(ContainerInterface $container, string $serviceName, callable $callback): Application { $app = $callback(); assert($app instanceof Application); $app-&gt;get('/books', [GetBooksHandler::class], 'books::list'); return $app; } } Handling the Request Now that the route exists, we need to create the class that will handle our request. Create a new directory src/Book/src/Handler and create the file GetBooksHandler.php . &lt;?php declare(strict_types=1); namespace Light\\Book\\Handler; use Laminas\\Diactoros\\Response\\HtmlResponse; use Light\\Book\\Repository\\BookRepository; use Mezzio\\Template\\TemplateRendererInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class GetBooksHandler implements RequestHandlerInterface { public function __construct( protected TemplateRendererInterface $template, protected BookRepository $bookRepository, ) { } public function handle(ServerRequestInterface $request): ResponseInterface { $titles = $this-&gt;bookRepository-&gt;getTitles(); $authors = $this-&gt;bookRepository-&gt;getAuthors(); return new HtmlResponse( $this-&gt;template-&gt;render('page::books', [ 'titles' =&gt; $titles, 'authors' =&gt; $authors, ]) ); } } The custom functions that we have created in the BookRepository.php retrieve our desired values and pass it to the books HTML template that is being rendered. We will crate the HTML file in the next part of this chapter. Twig Template for Book Listing The books template is currently missing, we now need to create it under the following path: src/Book/src/templates/page/books.html.twig . {% extends '@layout/default.html.twig' %} {% block title %}Books{% endblock %} {% block content %} &lt;div class=\"container\"&gt; &lt;h2&gt;Book Titles&lt;/h2&gt; &lt;table class=\"table table-bordered\" style=\"table-layout: fixed;\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Book ID&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {% for title in titles %} &lt;tr&gt; &lt;td&gt;{{ title.id }}&lt;/td&gt; &lt;td&gt;{{ title.title }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; &lt;h2&gt;Book Authors&lt;/h2&gt; &lt;table class=\"table table-bordered\" style=\"table-layout: fixed;\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Book ID&lt;/th&gt; &lt;th&gt;Author&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {% for author in authors %} &lt;tr&gt; &lt;td&gt;{{ author.id }}&lt;/td&gt; &lt;td&gt;{{ author.author }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; {% endblock %} Registering our Changes Now that our route, handler, repository methods and view are ready, we need to register them so the application can use them . In src/Book/src/ConfigProvider.php we need to add the following changes: public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), 'doctrine' =&gt; $this-&gt;getDoctrineConfig(), 'templates' =&gt; $this-&gt;getTemplates(), ]; } private function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, ], ], 'factories' =&gt; [ GetBooksHandler::class =&gt; BookHandlerFactory::class, BookRepository::class =&gt; BookRepositoryFactory::class, ], ]; } /** * @return array{ * paths: array{page: array{literal-string&amp;non-falsy-string}} * } */ private function getTemplates(): array { return [ 'paths' =&gt; [ 'page' =&gt; [__DIR__ . '/../templates/page'], ], ]; } In Dotkernel (and Mezzio/Laminas in general), most classes cannot be created directly with new ClassName() because they require dependencies (such as the template engine or a repository). To provide those dependencies, we create Factory classes. A factory’s only responsibility is to build an object with everything it needs. For that, we have created two factories - one for our Handler and one for our Repository. src/App/src/Factory/BookHandlerFactory.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Factory; use Light\\Book\\Handler\\GetBooksHandler; use Light\\Book\\Repository\\BookRepository; use Mezzio\\Template\\TemplateRendererInterface; use Psr\\Container\\ContainerExceptionInterface; use Psr\\Container\\ContainerInterface; use Psr\\Container\\NotFoundExceptionInterface; use function assert; class BookHandlerFactory { /** * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ public function __invoke(ContainerInterface $container, string $requestedName): GetBooksHandler { $repository = $container-&gt;get(BookRepository::class); $template = $container-&gt;get(TemplateRendererInterface::class); assert($repository instanceof BookRepository); assert($template instanceof TemplateRendererInterface); return new GetBooksHandler($template, $repository); } } src/App/src/Factory/BookRepositoryFactory.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Factory; use Doctrine\\ORM\\EntityManager; use Light\\Book\\Entity\\Book; use Light\\Book\\Repository\\BookRepository; use Psr\\Container\\ContainerExceptionInterface; use Psr\\Container\\ContainerInterface; use Psr\\Container\\NotFoundExceptionInterface; use function assert; class BookRepositoryFactory { /** * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ public function __invoke(ContainerInterface $container): BookRepository { $entityManager = $container-&gt;get(EntityManager::class); $repository = $entityManager-&gt;getRepository(Book::class); assert($repository instanceof BookRepository); return $repository; } } All the changes are now registered. Populating the Table In order to have values for us to display, we now have to populate our books table from our database with some values. There are two options in this case: Use Doctrine Fixtures Add entries manually from the Database Client. We recommend using fixtures , but if you choose the alternative approach, feel free to skip directly to the final section of this chapter. Doctrine Fixtures Doctrine Fixtures are tools that let us preload sample data into the database. They make it easy to populate entities automatically, so we can test and develop our application without adding data manually. Our first step is to add our required Doctrine packages to our composer.json file: \"doctrine/data-fixtures\": \"^2.2\", \"doctrine/doctrine-fixtures-bundle\": \"^4.3\", After importing our packages, we need to register the path for our Fixture files in src/App/src/ConfigProvider.php . 'fixtures' =&gt; getcwd() . '/src/App/src/Fixture', We now need to create our Fixture Loader in src/App/src/Fixture/BookLoader.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Fixture; use Doctrine\\Bundle\\FixturesBundle\\Fixture; use Doctrine\\Persistence\\ObjectManager; use Light\\Book\\Entity\\Book; class BookLoader extends Fixture { public function load(ObjectManager $manager): void { $book1 = new Book(); $book1-&gt;setTitle('A Game of Thrones'); $book1-&gt;setAuthor('George Martin'); $manager-&gt;persist($book1); $book2 = new Book(); $book2-&gt;setTitle('The Lord of the Rings'); $book2-&gt;setAuthor('J.R.R. Tolkien'); $manager-&gt;persist($book2); $book3 = new Book(); $book3-&gt;setTitle('Dune'); $book3-&gt;setAuthor('Frank Herbert'); $manager-&gt;persist($book3); $manager-&gt;flush(); } } For our last step we only need to create an executable for our fixtures in bin/doctrine-fixtures : #!/usr/bin/env php &lt;?php declare(strict_types=1); use Doctrine\\Common\\DataFixtures\\Executor\\ORMExecutor; use Doctrine\\Common\\DataFixtures\\Loader; use Doctrine\\Common\\DataFixtures\\Purger\\ORMPurger; use Doctrine\\ORM\\EntityManager; require_once 'vendor/autoload.php'; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $config = $container-&gt;get('config'); // Get fixtures directory from config $fixturesPath = $config['doctrine']['fixtures']; if (! is_dir($fixturesPath)) { echo \"Fixtures directory not found: {$fixturesPath}\\n\"; exit(1); } // Load fixtures $loader = new Loader(); $loader-&gt;loadFromDirectory($fixturesPath); // Execute fixtures $purger = new ORMPurger(); $executor = new ORMExecutor($entityManager, $purger); echo \"Loading fixtures from: {$fixturesPath}\\n\"; $executor-&gt;execute($loader-&gt;getFixtures()); echo \"Fixtures loaded successfully!\\n\"; Now we can run: php bin/doctrine-fixtures The output should be similar to this: Loading fixtures from: {{ your_path }} Fixtures loaded successfully! Listing Result In order to see your changes either go to {{base_url}}/books in your browser or you can add for example a button in src/App/templates/layout/default.html . &lt;a class=\"dropdown-item\" href=\"{{ url('books::list') }}\"&gt;Books&lt;/a&gt; We should now see a page similar to the following: Summary [Modified] src/Book/src/Repository/BookRepository.php [+] src/Book/src/RoutesDelegator.php [+] src/Book/src/Handler/GetBooksHandler.php [+] src/Book/templates/page/books.html.twig [Modified] src/Book/src/ConfigProvider.php [+] src/App/src/Factory/BookHandlerFactory.php [+] src/App/src/Factory/BookRepositoryFactory.php Fixtures (Optional): [Modified] composer.json [Modified] src/App/src/ConfigProvider.php [+] src/App/src/Fixture/BookLoader.php [+] bin/doctrine-fixtures [Modified] src/App/templates/layout/default.html.twig","title":"3. Fixtures and Custom Listing"},{"location":"v1/chapter-3/#fixtures-and-custom-listing","text":"In the previous chapter, after we have created our Entities we have talked briefly about their related Repositories. In this chapter we are going to have a closer look at them along with a custom listing of our books.","title":"Fixtures and Custom Listing"},{"location":"v1/chapter-3/#repository-logic-update","text":"Our goal is to create two custom functions that would retrieve the titles and the authors separately from each book. In src/Book/src/Respository/BookRepository.php we should add the following code: /** * @return array&lt;int, array{id: non-empty-string, title: string}&gt; */ public function getTitles(): array { $qb = $this-&gt;getQueryBuilder() -&gt;select('book.id, book.title') -&gt;from(Book::class, 'book'); return $qb-&gt;getQuery()-&gt;getResult(); } /** * @return array&lt;int, array{id: non-empty-string, author: string}&gt; */ public function getAuthors(): array { $qb = $this-&gt;getQueryBuilder() -&gt;select('book.id, book.author') -&gt;from(Book::class, 'book'); return $qb-&gt;getQuery()-&gt;getResult(); } The functions listed above will retrieve the title / author along with the ID of the Book database row for reference.","title":"Repository Logic Update"},{"location":"v1/chapter-3/#setting-up-the-route","text":"We will now work on setting up the route from our new module through which we will display our data. For this tutorial our route will be {{base_url}}/books . In order to register this path we need to create a RoutesDelegator.php file in src/Book/src . &lt;?php declare(strict_types=1); namespace Light\\Book; use Light\\Book\\Handler\\GetBooksHandler; use Mezzio\\Application; use Psr\\Container\\ContainerInterface; use function assert; class RoutesDelegator { public function __invoke(ContainerInterface $container, string $serviceName, callable $callback): Application { $app = $callback(); assert($app instanceof Application); $app-&gt;get('/books', [GetBooksHandler::class], 'books::list'); return $app; } }","title":"Setting up the Route"},{"location":"v1/chapter-3/#handling-the-request","text":"Now that the route exists, we need to create the class that will handle our request. Create a new directory src/Book/src/Handler and create the file GetBooksHandler.php . &lt;?php declare(strict_types=1); namespace Light\\Book\\Handler; use Laminas\\Diactoros\\Response\\HtmlResponse; use Light\\Book\\Repository\\BookRepository; use Mezzio\\Template\\TemplateRendererInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class GetBooksHandler implements RequestHandlerInterface { public function __construct( protected TemplateRendererInterface $template, protected BookRepository $bookRepository, ) { } public function handle(ServerRequestInterface $request): ResponseInterface { $titles = $this-&gt;bookRepository-&gt;getTitles(); $authors = $this-&gt;bookRepository-&gt;getAuthors(); return new HtmlResponse( $this-&gt;template-&gt;render('page::books', [ 'titles' =&gt; $titles, 'authors' =&gt; $authors, ]) ); } } The custom functions that we have created in the BookRepository.php retrieve our desired values and pass it to the books HTML template that is being rendered. We will crate the HTML file in the next part of this chapter.","title":"Handling the Request"},{"location":"v1/chapter-3/#twig-template-for-book-listing","text":"The books template is currently missing, we now need to create it under the following path: src/Book/src/templates/page/books.html.twig . {% extends '@layout/default.html.twig' %} {% block title %}Books{% endblock %} {% block content %} &lt;div class=\"container\"&gt; &lt;h2&gt;Book Titles&lt;/h2&gt; &lt;table class=\"table table-bordered\" style=\"table-layout: fixed;\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Book ID&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {% for title in titles %} &lt;tr&gt; &lt;td&gt;{{ title.id }}&lt;/td&gt; &lt;td&gt;{{ title.title }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; &lt;h2&gt;Book Authors&lt;/h2&gt; &lt;table class=\"table table-bordered\" style=\"table-layout: fixed;\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Book ID&lt;/th&gt; &lt;th&gt;Author&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {% for author in authors %} &lt;tr&gt; &lt;td&gt;{{ author.id }}&lt;/td&gt; &lt;td&gt;{{ author.author }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; {% endblock %}","title":"Twig Template for Book Listing"},{"location":"v1/chapter-3/#registering-our-changes","text":"Now that our route, handler, repository methods and view are ready, we need to register them so the application can use them . In src/Book/src/ConfigProvider.php we need to add the following changes: public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), 'doctrine' =&gt; $this-&gt;getDoctrineConfig(), 'templates' =&gt; $this-&gt;getTemplates(), ]; } private function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, ], ], 'factories' =&gt; [ GetBooksHandler::class =&gt; BookHandlerFactory::class, BookRepository::class =&gt; BookRepositoryFactory::class, ], ]; } /** * @return array{ * paths: array{page: array{literal-string&amp;non-falsy-string}} * } */ private function getTemplates(): array { return [ 'paths' =&gt; [ 'page' =&gt; [__DIR__ . '/../templates/page'], ], ]; } In Dotkernel (and Mezzio/Laminas in general), most classes cannot be created directly with new ClassName() because they require dependencies (such as the template engine or a repository). To provide those dependencies, we create Factory classes. A factory’s only responsibility is to build an object with everything it needs. For that, we have created two factories - one for our Handler and one for our Repository. src/App/src/Factory/BookHandlerFactory.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Factory; use Light\\Book\\Handler\\GetBooksHandler; use Light\\Book\\Repository\\BookRepository; use Mezzio\\Template\\TemplateRendererInterface; use Psr\\Container\\ContainerExceptionInterface; use Psr\\Container\\ContainerInterface; use Psr\\Container\\NotFoundExceptionInterface; use function assert; class BookHandlerFactory { /** * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ public function __invoke(ContainerInterface $container, string $requestedName): GetBooksHandler { $repository = $container-&gt;get(BookRepository::class); $template = $container-&gt;get(TemplateRendererInterface::class); assert($repository instanceof BookRepository); assert($template instanceof TemplateRendererInterface); return new GetBooksHandler($template, $repository); } } src/App/src/Factory/BookRepositoryFactory.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Factory; use Doctrine\\ORM\\EntityManager; use Light\\Book\\Entity\\Book; use Light\\Book\\Repository\\BookRepository; use Psr\\Container\\ContainerExceptionInterface; use Psr\\Container\\ContainerInterface; use Psr\\Container\\NotFoundExceptionInterface; use function assert; class BookRepositoryFactory { /** * @throws ContainerExceptionInterface * @throws NotFoundExceptionInterface */ public function __invoke(ContainerInterface $container): BookRepository { $entityManager = $container-&gt;get(EntityManager::class); $repository = $entityManager-&gt;getRepository(Book::class); assert($repository instanceof BookRepository); return $repository; } } All the changes are now registered.","title":"Registering our Changes"},{"location":"v1/chapter-3/#populating-the-table","text":"In order to have values for us to display, we now have to populate our books table from our database with some values. There are two options in this case: Use Doctrine Fixtures Add entries manually from the Database Client. We recommend using fixtures , but if you choose the alternative approach, feel free to skip directly to the final section of this chapter.","title":"Populating the Table"},{"location":"v1/chapter-3/#doctrine-fixtures","text":"Doctrine Fixtures are tools that let us preload sample data into the database. They make it easy to populate entities automatically, so we can test and develop our application without adding data manually. Our first step is to add our required Doctrine packages to our composer.json file: \"doctrine/data-fixtures\": \"^2.2\", \"doctrine/doctrine-fixtures-bundle\": \"^4.3\", After importing our packages, we need to register the path for our Fixture files in src/App/src/ConfigProvider.php . 'fixtures' =&gt; getcwd() . '/src/App/src/Fixture', We now need to create our Fixture Loader in src/App/src/Fixture/BookLoader.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Fixture; use Doctrine\\Bundle\\FixturesBundle\\Fixture; use Doctrine\\Persistence\\ObjectManager; use Light\\Book\\Entity\\Book; class BookLoader extends Fixture { public function load(ObjectManager $manager): void { $book1 = new Book(); $book1-&gt;setTitle('A Game of Thrones'); $book1-&gt;setAuthor('George Martin'); $manager-&gt;persist($book1); $book2 = new Book(); $book2-&gt;setTitle('The Lord of the Rings'); $book2-&gt;setAuthor('J.R.R. Tolkien'); $manager-&gt;persist($book2); $book3 = new Book(); $book3-&gt;setTitle('Dune'); $book3-&gt;setAuthor('Frank Herbert'); $manager-&gt;persist($book3); $manager-&gt;flush(); } } For our last step we only need to create an executable for our fixtures in bin/doctrine-fixtures : #!/usr/bin/env php &lt;?php declare(strict_types=1); use Doctrine\\Common\\DataFixtures\\Executor\\ORMExecutor; use Doctrine\\Common\\DataFixtures\\Loader; use Doctrine\\Common\\DataFixtures\\Purger\\ORMPurger; use Doctrine\\ORM\\EntityManager; require_once 'vendor/autoload.php'; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $config = $container-&gt;get('config'); // Get fixtures directory from config $fixturesPath = $config['doctrine']['fixtures']; if (! is_dir($fixturesPath)) { echo \"Fixtures directory not found: {$fixturesPath}\\n\"; exit(1); } // Load fixtures $loader = new Loader(); $loader-&gt;loadFromDirectory($fixturesPath); // Execute fixtures $purger = new ORMPurger(); $executor = new ORMExecutor($entityManager, $purger); echo \"Loading fixtures from: {$fixturesPath}\\n\"; $executor-&gt;execute($loader-&gt;getFixtures()); echo \"Fixtures loaded successfully!\\n\"; Now we can run: php bin/doctrine-fixtures The output should be similar to this: Loading fixtures from: {{ your_path }} Fixtures loaded successfully!","title":"Doctrine Fixtures"},{"location":"v1/chapter-3/#listing-result","text":"In order to see your changes either go to {{base_url}}/books in your browser or you can add for example a button in src/App/templates/layout/default.html . &lt;a class=\"dropdown-item\" href=\"{{ url('books::list') }}\"&gt;Books&lt;/a&gt; We should now see a page similar to the following:","title":"Listing Result"},{"location":"v1/introduction/","text":"Introduction For the upcoming tutorial steps we assume that you already have installed the following: A UNIX-based development environment. If not, we recommend AlmaLinux in a WSL2 container. You can check our guide for setting up your container. A recent IDE, for example, PhpStorm or VSCode A fresh installation of Dotkernel Light Default UTF-8 encoding for files and LF type line separator Feel free to check out our development documentation in case of any further questions.","title":"Introduction"},{"location":"v1/introduction/#introduction","text":"For the upcoming tutorial steps we assume that you already have installed the following: A UNIX-based development environment. If not, we recommend AlmaLinux in a WSL2 container. You can check our guide for setting up your container. A recent IDE, for example, PhpStorm or VSCode A fresh installation of Dotkernel Light Default UTF-8 encoding for files and LF type line separator Feel free to check out our development documentation in case of any further questions.","title":"Introduction"}]}