{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tutorial-101 Book tutorial starting from Dotkernel Light: Level 101 beginner","title":"Home"},{"location":"#tutorial-101","text":"Book tutorial starting from Dotkernel Light: Level 101 beginner","title":"tutorial-101"},{"location":"v1/chapter-1/","text":"Installing Doctrine Composer Requirements The first step is to add alongside your current packages the required entries for our Doctrine installation. We would add the following to our composer.json file located in our root folder: \"dotkernel/dot-cache\": \"^4.0\", \"ramsey/uuid\": \"^4.5.0\", \"ramsey/uuid-doctrine\": \"^2.1.0\", \"roave/psr-container-doctrine\": \"^5.2.2 || ^6.0.0\", dotkernel/dot-cache Provides caching support for Dotkernel applications. It offers a PSR-6 and PSR-16 compatible caching system that integrates smoothly with Dotkernel's service container. ramsey/uuid A widely used PHP library for generating and working with UUIDs (Universally Unique Identifiers). It supports multiple UUID versions. ramsey/uuid-doctrine Adds UUID support to Doctrine ORM using ramsey/uuid. It allows Doctrine to store and retrieve UUIDs as proper value objects instead of plain strings, improving type safety. roave/psr-container-doctrine Provides a set of factory classes that integrate Doctrine ORM with any PSR-11 container. It simplifies wiring Doctrine EntityManager, DBAL, configuration, and related services in frameworks like Dotkernel. phpstan/phpstan-doctrine (dev requirement) An extension for PHPStan that improves static analysis for Doctrine. It understands entity metadata, repositories, and common Doctrine patterns, helping catch errors during development. Setting Up Doctrine After successfully installing our dependencies, we now need to configure our Doctrine instance. Declare your database In the file config/autoload/local.php the structure would be updated like this: $databases = [ 'default' =&gt; [ 'host' =&gt; 'localhost', 'dbname' =&gt; 'light', 'user' =&gt; 'root', 'password' =&gt; '123', 'port' =&gt; 3306, 'driver' =&gt; 'pdo_mysql', 'charset' =&gt; 'utf8mb4', 'collate' =&gt; 'utf8mb4_general_ci', ], // you can add more database connections into this array ]; return [ 'databases' =&gt; $databases, 'doctrine' =&gt; [ 'connection' =&gt; [ 'orm_default' =&gt; [ 'params' =&gt; $databases['default'], ], ], ], // the rest of your configuration ]; Declare the Doctrine Drivers With the very nice utility of the package laminas/laminas-config-aggregator we can declare our doctrine settings in the src/App/src/ConfigProvider.php file. This package takes all the provided configs from the config/config.php file and merges them into one. Our new src/App/src/ConfigProvider.php class would look like this now: public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), 'doctrine' =&gt; $this-&gt;getDoctrineConfig(), 'templates' =&gt; $this-&gt;getTemplates(), ]; } public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, ], ], 'factories' =&gt; [ 'doctrine.entity_manager.orm_default' =&gt; EntityManagerFactory::class, GetIndexViewHandler::class =&gt; GetIndexViewHandlerFactory::class, ], 'aliases' =&gt; [ EntityManager::class =&gt; 'doctrine.entity_manager.orm_default', EntityManagerInterface::class =&gt; 'doctrine.entity_manager.orm_default', ], ]; } private function getDoctrineConfig(): array { return [ 'cache' =&gt; [ 'array' =&gt; [ 'class' =&gt; ArrayAdapter::class, ], 'filesystem' =&gt; [ 'class' =&gt; FilesystemAdapter::class, 'directory' =&gt; getcwd() . '/data/cache', 'namespace' =&gt; 'doctrine', ], ], 'configuration' =&gt; [ 'orm_default' =&gt; [ 'result_cache' =&gt; 'filesystem', 'metadata_cache' =&gt; 'filesystem', 'query_cache' =&gt; 'filesystem', 'hydration_cache' =&gt; 'array', 'typed_field_mapper' =&gt; null, 'second_level_cache' =&gt; [ 'enabled' =&gt; true, 'default_lifetime' =&gt; 3600, 'default_lock_lifetime' =&gt; 60, 'file_lock_region_directory' =&gt; '', 'regions' =&gt; [], ], ], ], 'driver' =&gt; [ // The default metadata driver aggregates all other drivers into a single one. // Override `orm_default` only if you know what you're doing. 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, ], ], 'types' =&gt; [ UuidType::NAME =&gt; UuidType::class, ], ]; } Running doctrine Now that everything has been configured we only need to do one last thing, to create an executable for the Doctrine CLI. In our case we will create a doctrine file inside the application's bin directory: #!/usr/bin/env php &lt;?php declare(strict_types=1); use Doctrine\\ORM\\EntityManager; use Doctrine\\ORM\\Tools\\Console\\ConsoleRunner; use Doctrine\\ORM\\Tools\\Console\\EntityManagerProvider\\SingleManagerProvider; require_once 'vendor/autoload.php'; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); ConsoleRunner::run(new SingleManagerProvider($entityManager)); Now by running the command bellow we should see the Doctrine CLI version alongside its available commands: php ./bin/doctrine Example (truncated) output: Doctrine Command Line Interface 3.5.7.0 Options: -h, --help Display help for the given command. When no command is given display help for the list command --silent Do not output any message -q, --quiet Only errors are displayed. All other output is suppressed -V, --version Display this application version --ansi|--no-ansi Force (or disable --no-ansi) ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug","title":"1. Installing Doctrine"},{"location":"v1/chapter-1/#installing-doctrine","text":"","title":"Installing Doctrine"},{"location":"v1/chapter-1/#composer-requirements","text":"The first step is to add alongside your current packages the required entries for our Doctrine installation. We would add the following to our composer.json file located in our root folder: \"dotkernel/dot-cache\": \"^4.0\", \"ramsey/uuid\": \"^4.5.0\", \"ramsey/uuid-doctrine\": \"^2.1.0\", \"roave/psr-container-doctrine\": \"^5.2.2 || ^6.0.0\", dotkernel/dot-cache Provides caching support for Dotkernel applications. It offers a PSR-6 and PSR-16 compatible caching system that integrates smoothly with Dotkernel's service container. ramsey/uuid A widely used PHP library for generating and working with UUIDs (Universally Unique Identifiers). It supports multiple UUID versions. ramsey/uuid-doctrine Adds UUID support to Doctrine ORM using ramsey/uuid. It allows Doctrine to store and retrieve UUIDs as proper value objects instead of plain strings, improving type safety. roave/psr-container-doctrine Provides a set of factory classes that integrate Doctrine ORM with any PSR-11 container. It simplifies wiring Doctrine EntityManager, DBAL, configuration, and related services in frameworks like Dotkernel. phpstan/phpstan-doctrine (dev requirement) An extension for PHPStan that improves static analysis for Doctrine. It understands entity metadata, repositories, and common Doctrine patterns, helping catch errors during development.","title":"Composer Requirements"},{"location":"v1/chapter-1/#setting-up-doctrine","text":"After successfully installing our dependencies, we now need to configure our Doctrine instance.","title":"Setting Up Doctrine"},{"location":"v1/chapter-1/#running-doctrine","text":"Now that everything has been configured we only need to do one last thing, to create an executable for the Doctrine CLI. In our case we will create a doctrine file inside the application's bin directory: #!/usr/bin/env php &lt;?php declare(strict_types=1); use Doctrine\\ORM\\EntityManager; use Doctrine\\ORM\\Tools\\Console\\ConsoleRunner; use Doctrine\\ORM\\Tools\\Console\\EntityManagerProvider\\SingleManagerProvider; require_once 'vendor/autoload.php'; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); ConsoleRunner::run(new SingleManagerProvider($entityManager)); Now by running the command bellow we should see the Doctrine CLI version alongside its available commands: php ./bin/doctrine Example (truncated) output: Doctrine Command Line Interface 3.5.7.0 Options: -h, --help Display help for the given command. When no command is given display help for the list command --silent Do not output any message -q, --quiet Only errors are displayed. All other output is suppressed -V, --version Display this application version --ansi|--no-ansi Force (or disable --no-ansi) ANSI output -n, --no-interaction Do not ask any interactive question -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug","title":"Running doctrine"},{"location":"v1/chapter-2/","text":"Entities and Migrations In the previous tutorial we have shown you how to install the basic functionality of Doctrine. In this tutorial we are going to show you how to make changes to the database schema through Entities and Migrations . What are Entities ? In Doctrine, entities are PHP classes that represent database tables. Each property in the class corresponds to a column in the table. Entities define the structure and behavior of your data. What are Migrations ? Doctrine migrations are version-controlled changes to the database schema. They allow you to safely update the structure of your database (create tables, add columns, etc.) over time — similar to Git for your database. Setting Up the Migrations Functionality To enable Doctrine migrations, we configure the migrations section in the getDoctrineConfig() function from src/App/ConfigProvider . This defines where migration files will be stored , as well as how the migration table is managed . The configuration includes settings for the migrations table, execution tracking, and the path where new migration classes will be generated. 'migrations' =&gt; [ 'table_storage' =&gt; [ 'table_name' =&gt; 'doctrine_migration_versions', 'version_column_name' =&gt; 'version', 'version_column_length' =&gt; 191, 'executed_at_column_name' =&gt; 'executed_at', 'execution_time_column_name' =&gt; 'execution_time', ], // Modify this line based on where you would like to have your migrations 'migrations_paths' =&gt; [ 'Migrations' =&gt; 'src/App/src/Migration', ], 'all_or_nothing' =&gt; true, 'check_database_platform' =&gt; true, ], Along with those we also need to create the file config/cli-config.php . This cli-config.php file sets up Doctrine so that you can run migration commands from the command line (CLI). It connects the Doctrine Migrations system with your application's existing EntityManager . &lt;?php declare(strict_types=1); use Doctrine\\Migrations\\Configuration\\EntityManager\\ExistingEntityManager; use Doctrine\\Migrations\\Configuration\\Migration\\ConfigurationArray; use Doctrine\\Migrations\\DependencyFactory; use Doctrine\\ORM\\EntityManager; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); return DependencyFactory::fromEntityManager( new ConfigurationArray($container-&gt;get('config')['doctrine']['migrations']), new ExistingEntityManager($entityManager) ); Used UUID type In our latest releases we have decided to switch from a binary UUID to a string UUID . Because of that, we are also implementing our own custom UUID type in the folder src/App/src/DBAL/Types/UuidType.php . With this method we can also add our own custom types in the future. &lt;?php declare(strict_types=1); namespace Light\\App\\DBAL\\Types; use Doctrine\\DBAL\\Platforms\\AbstractPlatform; class UuidType extends \\Ramsey\\Uuid\\Doctrine\\UuidType { public const NAME = 'uuid'; public function getSQLDeclaration(array $column, AbstractPlatform $platform): string { return 'UUID'; } } Testing Our Doctrine Migrations Configuration For easier usage of this functionality, we will create a file bin/doctrine-migrations . This will give us an easier way of executing migrations operations. #!/usr/bin/env php &lt;?php declare(strict_types=1); namespace Doctrine\\Migrations; require __DIR__ . '/../vendor/doctrine/migrations/bin/doctrine-migrations.php'; We can now call: php bin/doctrine-migrations The call should lead to a call that contains the following output: migrations:current [current] Outputs the current version migrations:diff [diff] Generate a migration by comparing your current database to your mapping information. migrations:dump-schema [dump-schema] Dump the schema for your database to a migration. migrations:execute [execute] Execute one or more migration versions up or down manually. migrations:generate [generate] Generate a blank migration class. migrations:latest [latest] Outputs the latest version migrations:list [list-migrations] Display a list of all available migrations and their status. migrations:migrate [migrate] Execute a migration to a specified version or the latest available version. migrations:rollup [rollup] Rollup migrations by deleting all tracked versions and insert the one version that exists. migrations:status [status] View the status of a set of migrations. migrations:sync-metadata-storage [sync-metadata-storage] Ensures that the metadata storage is at the latest version. migrations:up-to-date [up-to-date] Tells you if your schema is up-to-date. migrations:version [version] Manually add and delete migration versions from the version table. Creating our Entities Now that we have set up the Doctrine Migrations, we shall now start working on our entities. We need to create a base for our entities so that they have the same starting point. For that, we will add a new directory src/App/src/Entiy in which we will add an abstract class, AbstractEntity.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Entity; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; use Laminas\\Stdlib\\ArraySerializableInterface; use Ramsey\\Uuid\\Uuid; use Ramsey\\Uuid\\UuidInterface; use function is_array; use function method_exists; use function ucfirst; #[ORM\\MappedSuperclass] abstract class AbstractEntity implements ArraySerializableInterface { #[ORM\\Id] #[ORM\\Column(name: 'id', type: 'uuid', unique: true, nullable: false)] protected UuidInterface $id; #[ORM\\Column(name: 'created', type: 'datetime_immutable', nullable: false)] protected DateTimeImmutable $created; #[ORM\\Column(name: 'updated', type: 'datetime_immutable', nullable: true)] protected ?DateTimeImmutable $updated = null; public function __construct() { $this-&gt;id = Uuid::uuid7(); } public function getId(): UuidInterface { return $this-&gt;id; } public function setId(UuidInterface $id): static { $this-&gt;id = $id; return $this; } public function getCreated(): ?DateTimeImmutable { return $this-&gt;created; } public function getCreatedFormatted(string $dateFormat = 'Y-m-d H:i:s'): string { return $this-&gt;created-&gt;format($dateFormat); } public function getUpdated(): ?DateTimeImmutable { return $this-&gt;updated; } public function getUpdatedFormatted(string $dateFormat = 'Y-m-d H:i:s'): ?string { if ($this-&gt;updated instanceof DateTimeImmutable) { return $this-&gt;updated-&gt;format($dateFormat); } return null; } #[ORM\\PrePersist] public function created(): void { $this-&gt;created = new DateTimeImmutable(); } #[ORM\\PreUpdate] public function touch(): void { $this-&gt;updated = new DateTimeImmutable(); } /** * @param array&lt;non-empty-string, mixed&gt; $array */ public function exchangeArray(array $array): void { foreach ($array as $property =&gt; $values) { if (is_array($values)) { $method = 'add' . ucfirst($property); if (! method_exists($this, $method)) { continue; } foreach ($values as $value) { $this-&gt;$method($value); } } else { $method = 'set' . ucfirst($property); if (! method_exists($this, $method)) { continue; } $this-&gt;$method($values); } } } } We extend this class to any Entity that we create so that all can have an identifier( id ), a field for knowing when it was created and one to mark a point in time for when we update it. It is time to finally time to work on our Book Entity. We now create a new module with the location src/Book/src . In this module we create a directory called Entity in which we shall create our Book.php class. &lt;?php declare(strict_types=1); namespace Light\\Book\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Light\\App\\Entity\\AbstractEntity; use Light\\Book\\Repository\\BookRepository; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(name: 'books')] #[ORM\\HasLifecycleCallbacks] class Book extends AbstractEntity { #[ORM\\Column(name: 'title', type: 'string', length: 500)] private string $title; #[ORM\\Column(name: 'author', type: 'string', length: 500)] private string $author; public function getTitle(): ?string { return $this-&gt;title; } public function setTitle(string $title): void { $this-&gt;title = $title; } public function getAuthor(): ?string { return $this-&gt;author; } public function setAuthor(string $author): void { $this-&gt;author = $author; } /** * @return array{ * id: non-empty-string, * title: string, * author: string * } */ public function getArrayCopy(): array { return [ 'id' =&gt; $this-&gt;id-&gt;toString(), 'title' =&gt; $this-&gt;title, 'author' =&gt; $this-&gt;author, ]; } } In the book class you can see various Doctrine tags such as #[ORM\\Table(name: 'books')] which specify the name of the table that will be related to this Entity. There are many tags that can be added, but for the sake of simplicity, we will stick to the table and the columns that will populate it. Repositories In the class we created earlier, you may have noticed that our Entity is linked to a Repository using the following annotation: #[ORM\\Entity(repositoryClass: BookRepository::class)] . This specifies which Repository will handle queries for this Entity. This allows us to write custom database logic for it. Same as for the Entities, we need to create a base and our future Repositories. Because of that, we will create two new directories: src/App/src/Repository and src/Book/src/Repository . Two repositories shall be created: src/App/src/Repository/AbstractRepository.php &lt;?php declare(strict_types=1); namespace Light\\App\\Repository; use Doctrine\\ORM\\EntityRepository; use Doctrine\\ORM\\QueryBuilder; use Light\\App\\Entity\\EntityInterface; /** * @extends EntityRepository&lt;object&gt; */ class AbstractRepository extends EntityRepository { public function deleteResource(EntityInterface $resource): void { $this-&gt;getEntityManager()-&gt;remove($resource); $this-&gt;getEntityManager()-&gt;flush(); } public function getQueryBuilder(): QueryBuilder { return $this-&gt;getEntityManager()-&gt;createQueryBuilder(); } public function saveResource(EntityInterface $resource): void { $this-&gt;getEntityManager()-&gt;persist($resource); $this-&gt;getEntityManager()-&gt;flush(); } } src/App/src/Book/BookRepository.php &lt;?php declare(strict_types=1); namespace Light\\Book\\Repository; use Light\\App\\Repository\\AbstractRepository; class BookRepository extends AbstractRepository { /** * Any other custom methods can be added here */ } The BookRepository.php , for example, can implement functions that list books based on specific authors or titles. However, this will not be covered in this chapter of the tutorial. Final Steps We have 3 final steps: registering our Book module registering our new namespace in composer.json running the migrations Step 1 In order to register our new module, we need a new ConfigProvider.php in our src/Book/src folder. In this class we configure Doctrine to know from where to get our Entities. &lt;?php declare(strict_types=1); namespace Light\\Book; use Doctrine\\ORM\\Mapping\\Driver\\AttributeDriver; use Doctrine\\Persistence\\Mapping\\Driver\\MappingDriver; class ConfigProvider { public function __invoke(): array { return [ 'doctrine' =&gt; $this-&gt;getDoctrineConfig(), ]; } private function getDoctrineConfig(): array { return [ 'driver' =&gt; [ 'orm_default' =&gt; [ 'drivers' =&gt; [ 'Light\\Book\\Entity' =&gt; 'BookEntities', ], ], 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; [__DIR__ . '/Entity'], ], ], ]; } } This class should be added in config/config.php . \\Light\\Book\\ConfigProvider::class, Step 2 Registering the namespace is fairly simple. We just add it in our composer.json file by adding \"Light\\\\Book\\\\\": \"src/Book/src/\" under the autoload . psr-4 key: , \"Light\\\\Book\\\\\": \"src/Book/src/\" We now have to run the following command to have it registered: composer dump-autoload The module is now registered. Step 3 For the last step we will create a migration using our bin/doctrine-migrations file and then execute it: php bin/doctrine-migrations.php migrations:diff You should get an output similar to: Generated new migration class to \"src/App/src/Migration/Version20251127183637.php\" The migrations:diff flag tells Doctrine to compare our current database schema and create a file in which the differences will be transformed into SQL syntax. Inside this file you should have something similar to: final class Version20251127183637 extends AbstractMigration { public function getDescription(): string { return ''; } public function up(Schema $schema): void { // this up() migration is auto-generated, please modify it to your needs $this-&gt;addSql('CREATE TABLE books (title VARCHAR(500) DEFAULT NULL, author VARCHAR(500) DEFAULT NULL, id UUID NOT NULL, created DATETIME NOT NULL, updated DATETIME DEFAULT NULL, PRIMARY KEY (id)) DEFAULT CHARACTER SET utf8mb4'); } public function down(Schema $schema): void { // this down() migration is auto-generated, please modify it to your needs $this-&gt;addSql('DROP TABLE books'); } } We only have to execute the migrations now with the command: php bin/doctrine-migrations.php migrations:migrate The output should be similar to this: [OK] Successfully migrated to version: Migrations\\Version2025112718363","title":"2. Entities and Migrations"},{"location":"v1/chapter-2/#entities-and-migrations","text":"In the previous tutorial we have shown you how to install the basic functionality of Doctrine. In this tutorial we are going to show you how to make changes to the database schema through Entities and Migrations .","title":"Entities and Migrations"},{"location":"v1/chapter-2/#what-are-entities","text":"In Doctrine, entities are PHP classes that represent database tables. Each property in the class corresponds to a column in the table. Entities define the structure and behavior of your data.","title":"What are Entities ?"},{"location":"v1/chapter-2/#what-are-migrations","text":"Doctrine migrations are version-controlled changes to the database schema. They allow you to safely update the structure of your database (create tables, add columns, etc.) over time — similar to Git for your database.","title":"What are Migrations ?"},{"location":"v1/chapter-2/#setting-up-the-migrations-functionality","text":"To enable Doctrine migrations, we configure the migrations section in the getDoctrineConfig() function from src/App/ConfigProvider . This defines where migration files will be stored , as well as how the migration table is managed . The configuration includes settings for the migrations table, execution tracking, and the path where new migration classes will be generated. 'migrations' =&gt; [ 'table_storage' =&gt; [ 'table_name' =&gt; 'doctrine_migration_versions', 'version_column_name' =&gt; 'version', 'version_column_length' =&gt; 191, 'executed_at_column_name' =&gt; 'executed_at', 'execution_time_column_name' =&gt; 'execution_time', ], // Modify this line based on where you would like to have your migrations 'migrations_paths' =&gt; [ 'Migrations' =&gt; 'src/App/src/Migration', ], 'all_or_nothing' =&gt; true, 'check_database_platform' =&gt; true, ], Along with those we also need to create the file config/cli-config.php . This cli-config.php file sets up Doctrine so that you can run migration commands from the command line (CLI). It connects the Doctrine Migrations system with your application's existing EntityManager . &lt;?php declare(strict_types=1); use Doctrine\\Migrations\\Configuration\\EntityManager\\ExistingEntityManager; use Doctrine\\Migrations\\Configuration\\Migration\\ConfigurationArray; use Doctrine\\Migrations\\DependencyFactory; use Doctrine\\ORM\\EntityManager; $container = require 'config/container.php'; $entityManager = $container-&gt;get(EntityManager::class); $entityManager-&gt;getEventManager(); return DependencyFactory::fromEntityManager( new ConfigurationArray($container-&gt;get('config')['doctrine']['migrations']), new ExistingEntityManager($entityManager) );","title":"Setting Up the Migrations Functionality"},{"location":"v1/chapter-2/#used-uuid-type","text":"In our latest releases we have decided to switch from a binary UUID to a string UUID . Because of that, we are also implementing our own custom UUID type in the folder src/App/src/DBAL/Types/UuidType.php . With this method we can also add our own custom types in the future. &lt;?php declare(strict_types=1); namespace Light\\App\\DBAL\\Types; use Doctrine\\DBAL\\Platforms\\AbstractPlatform; class UuidType extends \\Ramsey\\Uuid\\Doctrine\\UuidType { public const NAME = 'uuid'; public function getSQLDeclaration(array $column, AbstractPlatform $platform): string { return 'UUID'; } }","title":"Used UUID type"},{"location":"v1/chapter-2/#testing-our-doctrine-migrations-configuration","text":"For easier usage of this functionality, we will create a file bin/doctrine-migrations . This will give us an easier way of executing migrations operations. #!/usr/bin/env php &lt;?php declare(strict_types=1); namespace Doctrine\\Migrations; require __DIR__ . '/../vendor/doctrine/migrations/bin/doctrine-migrations.php'; We can now call: php bin/doctrine-migrations The call should lead to a call that contains the following output: migrations:current [current] Outputs the current version migrations:diff [diff] Generate a migration by comparing your current database to your mapping information. migrations:dump-schema [dump-schema] Dump the schema for your database to a migration. migrations:execute [execute] Execute one or more migration versions up or down manually. migrations:generate [generate] Generate a blank migration class. migrations:latest [latest] Outputs the latest version migrations:list [list-migrations] Display a list of all available migrations and their status. migrations:migrate [migrate] Execute a migration to a specified version or the latest available version. migrations:rollup [rollup] Rollup migrations by deleting all tracked versions and insert the one version that exists. migrations:status [status] View the status of a set of migrations. migrations:sync-metadata-storage [sync-metadata-storage] Ensures that the metadata storage is at the latest version. migrations:up-to-date [up-to-date] Tells you if your schema is up-to-date. migrations:version [version] Manually add and delete migration versions from the version table.","title":"Testing Our Doctrine Migrations Configuration"},{"location":"v1/chapter-2/#creating-our-entities","text":"Now that we have set up the Doctrine Migrations, we shall now start working on our entities. We need to create a base for our entities so that they have the same starting point. For that, we will add a new directory src/App/src/Entiy in which we will add an abstract class, AbstractEntity.php : &lt;?php declare(strict_types=1); namespace Light\\App\\Entity; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; use Laminas\\Stdlib\\ArraySerializableInterface; use Ramsey\\Uuid\\Uuid; use Ramsey\\Uuid\\UuidInterface; use function is_array; use function method_exists; use function ucfirst; #[ORM\\MappedSuperclass] abstract class AbstractEntity implements ArraySerializableInterface { #[ORM\\Id] #[ORM\\Column(name: 'id', type: 'uuid', unique: true, nullable: false)] protected UuidInterface $id; #[ORM\\Column(name: 'created', type: 'datetime_immutable', nullable: false)] protected DateTimeImmutable $created; #[ORM\\Column(name: 'updated', type: 'datetime_immutable', nullable: true)] protected ?DateTimeImmutable $updated = null; public function __construct() { $this-&gt;id = Uuid::uuid7(); } public function getId(): UuidInterface { return $this-&gt;id; } public function setId(UuidInterface $id): static { $this-&gt;id = $id; return $this; } public function getCreated(): ?DateTimeImmutable { return $this-&gt;created; } public function getCreatedFormatted(string $dateFormat = 'Y-m-d H:i:s'): string { return $this-&gt;created-&gt;format($dateFormat); } public function getUpdated(): ?DateTimeImmutable { return $this-&gt;updated; } public function getUpdatedFormatted(string $dateFormat = 'Y-m-d H:i:s'): ?string { if ($this-&gt;updated instanceof DateTimeImmutable) { return $this-&gt;updated-&gt;format($dateFormat); } return null; } #[ORM\\PrePersist] public function created(): void { $this-&gt;created = new DateTimeImmutable(); } #[ORM\\PreUpdate] public function touch(): void { $this-&gt;updated = new DateTimeImmutable(); } /** * @param array&lt;non-empty-string, mixed&gt; $array */ public function exchangeArray(array $array): void { foreach ($array as $property =&gt; $values) { if (is_array($values)) { $method = 'add' . ucfirst($property); if (! method_exists($this, $method)) { continue; } foreach ($values as $value) { $this-&gt;$method($value); } } else { $method = 'set' . ucfirst($property); if (! method_exists($this, $method)) { continue; } $this-&gt;$method($values); } } } } We extend this class to any Entity that we create so that all can have an identifier( id ), a field for knowing when it was created and one to mark a point in time for when we update it. It is time to finally time to work on our Book Entity. We now create a new module with the location src/Book/src . In this module we create a directory called Entity in which we shall create our Book.php class. &lt;?php declare(strict_types=1); namespace Light\\Book\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Light\\App\\Entity\\AbstractEntity; use Light\\Book\\Repository\\BookRepository; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(name: 'books')] #[ORM\\HasLifecycleCallbacks] class Book extends AbstractEntity { #[ORM\\Column(name: 'title', type: 'string', length: 500)] private string $title; #[ORM\\Column(name: 'author', type: 'string', length: 500)] private string $author; public function getTitle(): ?string { return $this-&gt;title; } public function setTitle(string $title): void { $this-&gt;title = $title; } public function getAuthor(): ?string { return $this-&gt;author; } public function setAuthor(string $author): void { $this-&gt;author = $author; } /** * @return array{ * id: non-empty-string, * title: string, * author: string * } */ public function getArrayCopy(): array { return [ 'id' =&gt; $this-&gt;id-&gt;toString(), 'title' =&gt; $this-&gt;title, 'author' =&gt; $this-&gt;author, ]; } } In the book class you can see various Doctrine tags such as #[ORM\\Table(name: 'books')] which specify the name of the table that will be related to this Entity. There are many tags that can be added, but for the sake of simplicity, we will stick to the table and the columns that will populate it.","title":"Creating our Entities"},{"location":"v1/chapter-2/#repositories","text":"In the class we created earlier, you may have noticed that our Entity is linked to a Repository using the following annotation: #[ORM\\Entity(repositoryClass: BookRepository::class)] . This specifies which Repository will handle queries for this Entity. This allows us to write custom database logic for it. Same as for the Entities, we need to create a base and our future Repositories. Because of that, we will create two new directories: src/App/src/Repository and src/Book/src/Repository . Two repositories shall be created: src/App/src/Repository/AbstractRepository.php &lt;?php declare(strict_types=1); namespace Light\\App\\Repository; use Doctrine\\ORM\\EntityRepository; use Doctrine\\ORM\\QueryBuilder; use Light\\App\\Entity\\EntityInterface; /** * @extends EntityRepository&lt;object&gt; */ class AbstractRepository extends EntityRepository { public function deleteResource(EntityInterface $resource): void { $this-&gt;getEntityManager()-&gt;remove($resource); $this-&gt;getEntityManager()-&gt;flush(); } public function getQueryBuilder(): QueryBuilder { return $this-&gt;getEntityManager()-&gt;createQueryBuilder(); } public function saveResource(EntityInterface $resource): void { $this-&gt;getEntityManager()-&gt;persist($resource); $this-&gt;getEntityManager()-&gt;flush(); } } src/App/src/Book/BookRepository.php &lt;?php declare(strict_types=1); namespace Light\\Book\\Repository; use Light\\App\\Repository\\AbstractRepository; class BookRepository extends AbstractRepository { /** * Any other custom methods can be added here */ } The BookRepository.php , for example, can implement functions that list books based on specific authors or titles. However, this will not be covered in this chapter of the tutorial.","title":"Repositories"},{"location":"v1/chapter-2/#final-steps","text":"We have 3 final steps: registering our Book module registering our new namespace in composer.json running the migrations","title":"Final Steps"},{"location":"v1/introduction/","text":"Introduction For the upcoming tutorial steps we assume that you already have installed the following: A UNIX-based development environment. If not, we recommend AlmaLinux in a WSL2 container. You can check our guide for setting up your container. A recent IDE, for example, PhpStorm or VSCode A fresh installation of Dotkernel Light Default UTF-8 encoding for files and LF type line separator Feel free to check out our development documentation in case of any further questions.","title":"Introduction"},{"location":"v1/introduction/#introduction","text":"For the upcoming tutorial steps we assume that you already have installed the following: A UNIX-based development environment. If not, we recommend AlmaLinux in a WSL2 container. You can check our guide for setting up your container. A recent IDE, for example, PhpStorm or VSCode A fresh installation of Dotkernel Light Default UTF-8 encoding for files and LF type line separator Feel free to check out our development documentation in case of any further questions.","title":"Introduction"}]}